jvm组成：
	1.类加载器：将Java代码转化为字节码
	2.运行时数据区：将字节码文件加载到内存中
	3.执行引擎：将字节码编译成系统底层指令，再交由cpu执行
	4.本地库接口：当需要调用其他语言时

运行时数据区的组成：
	线程私有：java栈、本地方法栈、程序计数器
	线程共有：方法区、堆
栈：存放对象引用和基本数据类型
方法区：存放 class文件和 static变量与方法。
	运行时常量池在方法区中，可以存字符串常量等。
堆：存放一切new出来的对象

String.intern():先检查常量池有无当前对象，有则返回常量池中的地址，不存在就加入常量池


类加载器：
	1.自定义 ClassLoader
	2.Application ClassLoader
	3.Extension ClassLoader
	4.Bootstrap ClassLoader

类加载机制： 加载---连接（验证、准备、解析）---初始化---使用--卸载

双亲委派模型工作过程：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。
	每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求
	（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

双亲委派模型的好处：避免了java核心类与用户自定义类重名时产生错误。

打破双亲委派机制：使用自定义类加载器，重新loadClass方法。

JDK1.7之前 ：
	运行时常量池(包含 字符串常量池 )存放在 方法区，此时 hotspot 虚拟机对方法区的实现为永久代。
JDK1.7 ：
	字符串常量池 被从方法区拿到了堆中；运行时常量池 剩下的东西还在 方法区, 也就是hotspot中的永久代。
JDK1.8 ：
	hotspot移除了 永久代，用 元空间(Metaspace) 取而代之。
	这时候，字符串常量池还在堆,运行时常量池 还在方法区, 只不过方法区的实现从永久代变成元空间(Metaspace)。

在何处进行垃圾回收：
	1.方法区（永久代 Permanent Generation）：非堆。jkd8后，元空间取代永久代，元空间并不在虚拟机中，而是直接使用本地内存。
	2.堆：
	    	2.1新生代 占1/3堆空间（Young Generation）：对象朝生夕死，发生Minor GC非常频繁 ；
			新生带分为：Eden区（80%）,Survivor(from)区（10%），Survivor(to)区（10%）
			当Eden区无法存放新对象时，发生Minor GC
			发生gc时，对象在from区与to区来回倒，当达到一定次数(默认15次)后，对象进入老年代。

		2.2老年代 占2/3堆空间（Old Generation）：发生Full GC
					

如何判断对象已死
	1.引用计数算法：给对象添加一个引用计数器，每当有一个地方引用到，就+1
		优点：实现简单，判定效率高
		缺点：无法解决对象循环依赖的问题
	2.可达性分析算法：把所有的引用关系看作一张图，从一个节点GC ROOT 开始，寻找对应的引用节点，
		找到这个节点以后，继续寻找这个节点的引用节点。当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，

引用
	1.强引用：	Object ojb = new Object()。只要强引用还在，对象就不会被gc
	2.软引用：SoftReference<Object> sf = new SoftReference<Object>(new Object);内存不足时，会被回收
                         这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；
	3.弱引用：WeakReference<Object> wf = new WeakReference<Object> (new Object);只要gc就被回收
		弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。
		弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记
	4.虚引用：无法通过虚引用来取得一个对象实例。它的作用是能在这个对象被收集器回收时收到一个系统通知。

目前java 中可作为GC Root 的对象有：
	虚拟机栈中引用的对象（本地变量表）	
	方法区中静态属性引用的对象
	方法区中常量引用的对象
	本地方法栈中引用的对象（Native Object）

垃圾收集算法：
	1.标记-清楚算法：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
		缺点：标记和清除的效率不高，会产生大量不连续的内存碎片
	2.复制算法：针对新生代，将from区和eden区还活着的对象，移到to区
		分配担保：当survivor区没有足够的空间存放存活的对象，大对象直接进入老年代
		缺点：浪费了部分内存
	3.标记-整理算法：针对老年代，与1类似，但后续不是回收，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

垃圾收集器（互相搭配使用）：
	新生代：Serial，ParNew，Parllel Scavenge.
	老年代：Serial Old，Parallel Old，CMS.
Serial：单线程，使用复制算法
ParNew：多线程，其他与Serial类似
CMS：以获取最短回收停顿时间为目标的收集器。
	优点：并发收集，低停顿。基于“标记-清除”算法。
	缺点：对CPU资源非常敏感，无法处理浮动垃圾，基于“标记-清除”算法会产生大量空间碎片。

G1收集器：基于“标记-整理”算法实现收集器，非常精确地控制停顿

被标记为垃圾的对象不会马上被回收
	第一次标记：如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记；
	第二次标记：第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。
		在 finalize() 方法中没有重新与引用链建立关联关系的，将被进行第二次标记。第二次标记成功的对象将真的会被回收，
		如果对象在 finalize() 方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。



