面向对象三大特性：封装，继承，多态


创建对象流程：
    1.初始化父类静态属性
    2.调用父类静态代码块
    3.初始化子类静态属性
    4.调用子类静态代码块
    =================
    5.初始化父类非静态属性
    6.调用父类非静态代码块
    7.调用父类构造器中的方法
    =================
    8.初始化子类非静态属性
    9.调用子类非静态代码块
    10.调用子类构造器中的方法

静态方法不能被重写，但是可以被重载
当子类的静态方法和父类的静态方法完全相同时，执行时，使用的是子类的静态方法。

重写：方法名、参数、返回值完全相同（final修饰的方法无法被重写）
重载：参数类型、个数、顺序至少有一个不同（不能重载只有返回值不同的方法）



基本数据类型：
	整   型：byte, short, int, long
	字符型：char
	浮点型：float, double
	布尔型：boolean

对象在内存中的存储布局：markword（对象头）+类型指针+实例数据+对齐

对象头（MarkWord）记录了锁状态等信息。
	1.无锁态：对象的hashcode，分代年龄
	2.轻量级锁、3.重量级锁
	4.偏向锁：线程id，分代年龄，epoch
	5.gc标记
	

String：final修饰（线程安全），不可变，每次操作都会产生新的string对象
StringBuffer：在原对象上进行操作，线程安全
StringBuilder：在原对象上进行操作，线程不安全，性能最好

36、Java 中的final关键字有哪些用法？
(1)修饰类：表示该类不能被继承；
(2)修饰方法：表示方法不能被重写；
(3)修饰变量：对于 基本类型 来说，不可改变指的是变量当中的数据不可改变，
	对于 引用类型 来说，不可改变的指的是变量当中的地址值不可改变



数组与链表
	数组：	1.在内存中是一块连续的区域。
	     	2.大小在初始化时就给定，当扩容时，需要将旧数组中的元素，向新数组中移动
		3.插入和删除的效率低，插入和删除时，都会涉及到元素的向前或者向后移动
	    	4.随机查询效率高，时间复杂度为O(1)
		5.数组的空间从栈中分配
	链表：	1.由一个个节点组成，在内存中不一定连续
		2.空间利用率高，可以根据需求动态申请和删除节点。
		3.插入和删除效率相对数组更高，改变指针指向即可。
		4.随机查询效率相对数组更低，需要从头节点依次遍历
		5.内存从堆中分配。


容器分为：collection 和 map
collection分为：list（有序可重复），set（无序不可重复）

ArrayList：底层基于数组实现，适合随机查询多的场景；//插入和添加时可能会涉及到扩容和移位
LinkedList：底层基于链表实现，适合增删改多的场景；此外，还实现了Deque接口，可以当队列来使用。

HashMap：线程不安全，key和value都可以为空，数组默认长度为16；
HashTable：与hashmap几乎相同，但是线程安全（get/put都是synchronized），不允许key和value为空。多线程下效率低。
ConcurrentHashMap：采用锁分段技术，分段后，每段类似一个HashTable。效率更高。

HashMap的容量为什么要初始化为2的n次幂？
为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同。
在进行put()时，会先将key的hash和size-1进行&运算，得到node在数组中的位置。
当size为2的n次幂时，size-1的二进制全为1，不同key算到index相同的几率较小。使数据分配均匀。

默认扩容因子为什么是0.75？
趋近于1，数组中的存放的数据(Node)也就越多，也就越稠密，也就是会让链表的长度增加，降低查询效率
趋近于 0 ，数组中的存放的数据 (Node) 也就越少，也就越稀疏，也就是会让链表的长度不会太长，降低内存利用率

红黑树：没有一条路径会比其它路径长出两倍。
	0.每个节点非红即黑，1.根节点和叶子节点为黑色，2.两个红色节点不能直接相连，
	3.对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;
AVL树（平衡二叉树）：所有节点的左右子树高度差的绝对值不超过1

为什么hashmap用红黑树不用avl树？
	alv树插入效率比红黑树低，因为avl树更加严格平衡，avl树地旋转更难实现和调试。（虽然avl树查找效率高（深度小））


hashmap为什么线程不安全？：没有加锁。
	1.7以前：并发执行扩容操作时会造成环形链和数据丢失的情况。
		使用了头插法，




队列中：offer():添加失败时，返回false；add():添加失败时，抛异常

抽象类的意义就是用来给子类继承的，所以不能被final修饰
抽象类：抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。
	可以定义构造器，
	可以有抽象方法和具体方法。  ##子类直接调用super()就可以调用父类中已经写好的方法。或者子类可以直接重写父类的方法
	一个类只能继承一个抽象类
	可以有静态方法

接口：
	不能定义构造器
	全部都是抽象方法
	不能有静态方法
	一个类可以实现多个接口

31、String s = new String("xyz");创建了几个字符串对象？
答：两个对象，一个是静态区的"xyz"，一个是用new创建在堆上的对象。


单例模式：
1.懒汉式加载：第一次调用的时候实例化自己，（线程不一定安全）
2.饿汉式加载：类加载完成后就已经创建好了实例，（线程安全）


如果 catch 中 return 了，finally 还会执行吗？     会执行，执行return之前会先执行finally。
阿里不建议在finally中return，因为就不会执行正常流程下的return了。

finally 是不是一定会被执行到？
不一定。下面列举两种执行不到的情况：
（1）当程序进入 try 块之前就出现异常时，会直接结束，不会执行 finally 块中的代码；
（2）当程序在 try 块中强制退出时也不会去执行 finally 块中的代码，比如在 try 块中执行 exit 方法。


常见异常：空指针，数组越界，文件未找到，类型转化异常




页面置换算法：OPT、FIFO、LRU、LFU
FIFO：先进先出（优先淘汰最早进入内存的页面）
LRU：选择最近最长时间未访问过的页面予以淘汰。实现方式：hashmap+双向链表
LFU：选择最近最少使用的页面予以淘汰	         



equals与hashcode：
	判断两个对象是否相等，先比较其hashcode是否相同，相等时，再调用equals方法判断是否相等。
	所以，重写了equals方法，一定要重写hashcode方法，否则，会造成，明明两个对象相等，但是结果为false的情况
















