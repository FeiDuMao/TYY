进程：是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。
线程：是 cpu 调度和分派的基本单位
	五种状态：创建（new）、就绪（runnable）、运行（running）、阻塞（blocked）、死亡（dead）
	
	每个线程有自己的栈，共享一个堆
	
.run()：没有真正开启一个新线程，而是在当前线程下执行了另一个线程的run()方法
.start()：会开启一个新线程，并且会调用新线程里面的run()方法。

进程间通信：

内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。
	当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。

系统调用：用户态程序切换到内核态, 但是不能控制在内核态中执行的指令

用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。

从用户态切换到内核态：1.系统调用  2.异常   3.外围设备的中断

为什么要有用户态和内核态？
	由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络,
	 CPU划分出两个权限等级 -- 用户态和内核态。


创建线程的方法：
	1.继承thread类，重写run方法
	2.实现runnable接口s	//new Thread的时候把runnable对象传进去
	3.使用Callable和Future创建线程
	4.使用线程池
	
Runnable 接口中的 run() 方法的返回值是 void，它做的事情只是纯粹地去执行 run() 方法中的代码而已；
Callable 接口中的 call() 方法是有返回值的，是一个泛型，和 Future、FutureTask 配合可以用来获取异步执行的结果。

sleep()、wait()、yeild()、join()方法的区别：
	1.sleep是thread类中的本地方法，wait是object类中的本地方法。
	2.sleep不会释放lock，将当前线程变为阻塞状态
	3.wait会释放lock，需要别的线程调用notify来将其唤醒
	4.sleep不需要被唤醒，wait需要。
	5.yeild只是将当前线程转变为就绪状态，不一定会获取cpu
	6.a.join()被调用后，会等待a线程执行完成之后，才会继续往下走	


线程数与cpu核心关系：
	IO密集型=2Ncpu（可以测试后自己控制大小，2Ncpu一般没问题）
	（常出现于线程中：数据库数据交互、文件上传下载、网络数据传输等等）

	计算密集型=Ncpu（常出现于线程中：复杂算法）


线程池：	
	执行优先级：核心线程>非核心线程
	提交优先级：核心线程>任务队列>非核心线程
	（线程池执行任务的时候，优先将任务提交给核心线程执行，如果核心线程已满，则提交到任务队列中等待，
	   如果任务队列也满了，就将任务提交给非核心线程执行，如果非核心线程也满，就触发拒绝策略。）

线程池参数：
	1.核心线程数
	2.线程池最大线程数量
	3.空闲线程（非核心线程）存活时间
	4.时间单位
	5.工作队列：有4种队列（）
	6.线程工厂（可以设置线程名等）
	7.拒绝策略：有4种拒绝策略
任务队列：（ArrayBlockingQueue：有界，满了就触发拒绝策略）
	（LinkedBlockingQuene：无界，可能会产生oom问题）
	（SynchronousQuene：新添加任务时，不缓存，直接调度执行该任务，如果线程数已满，则触发拒绝策略）
	（PriorityBlockingQueue：具有优先级的无界阻塞队列）
拒绝策略：（AbortPolicy：直接丢弃任务，然后抛异常）
	（DiscardPolicy：直接丢弃任务）
	（CallerRunsPolicy：在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。）
	（DiscardOldestPolicy：抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列）


volatile ：仅能使用在变量级别，仅能实现变量的修改可见性，不能保证原子性；
	保证了不同线程对该变量操作的内存可见性; 禁止指令重排序。

可见性：每个线程拥有自己的一个高速缓存区——线程工作内存：一个线程修改了共享变量值，而另一个线程却看不到。
（1）修改volatile变量时会强制将修改后的值刷新的主内存中。
（2）修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。


Synchronized与lock：
	Synchronized是内置的java关键字，会自动释放锁，无法获取锁的状态
	Synchronized锁的对象是方法的调用者。

	lock是一个类，需要手动释放锁，可以获取锁的状态，灵活度高（可以自己设定是否公平，在哪里上锁和解锁）

Synchronized实现原理：（锁的是一个对象）对象头中的保存了锁状态，
	任何对象都有一个监视器锁（monitor）关联，线程执行monitorenter指令时尝试获取monitor的所有权。

锁状态（锁可以升级不可以降级，但是偏向锁状态可以被重置为无锁状态）：由低到高：
 1.无锁
 2.偏向锁 ：大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，
	因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入的偏向锁。
 3.轻量级锁   ：轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因为阻塞线程需要CPU从用户态转到内核态，代价较大。
	不阻塞线程，让线程自旋等待。
 4.重量级锁：使线程进入阻塞状态，适用于多个线程竞争锁的场景

Synchronized锁优化：
	1.锁粗化：扩大锁的范围（将锁从循环内放到循环外，减少加锁的开销）
	2.锁消除：消除没有必要的锁：（ Synchronized(new Object) ）
	3.锁升级

ReentrantLock实现原理：使用CAS+AQS（抽象同步队列）
	先通过CAS尝试获取锁。如果此时已经有线程占据了锁，那就加入AQS队列并且被挂起。当锁被释放之后，排在CLH队列队首的线程会被唤醒，
	然后CAS再次尝试获取锁。在这个时候，如果：

	非公平锁：如果同时还有另一个线程进来尝试获取，那么有可能会让这个线程抢先获取；
	公平锁：如果同时还有另一个线程进来尝试获取，当它发现自己不是在队首的话，就会排到队尾，由队首的线程获取到锁。

ThreadLocal保证线程安全：让线程有自己的“局部变量”，于是就避免了资源的竞争。
	线程本地变量的生命周期与线程绑定，可能会发生内存溢出的情况。需要变量用完以后，需要手动调用remove().

ThreadLocal实现原理：每个Thread有自己的ThreadLocals，存放在自己的ThreadLocalMap（类似hashmap，基于数组）中，
		ThreadLocalMap中每一个Entry节点，分为key（弱引用，指向ThreadLocal对象） 和value（强引用）。  
		由于value是强引用，仍可能发生内存溢出，需要手动调用remove()。
		当通过ThreadLocal对象set()时，线程创建一个Entry，保存在自己的ThreadLocalMap中。
		当通过ThreadLocal对象get()时，线程是从自己的ThreadLocalMap中取。进而保证线程安全
	

ThreadLocal中为什么有弱引用？
	当外部出现：ThreadLocal threadlocal=new ThreadLocal（）；然后将 threadlocal=null；
	此时，外部无法再访问ThreadLocal之前的对象，如果key是强引用，那么原来的对象就永远不会被清除，从而产生内存泄漏。


防止虚假唤醒：等待总应该出现在循环（while）中。



死锁：
	产生条件：1.资源互斥。2.不可抢占。3.占有且等待。4.循环等待。
	
	预防：打破引发条件。
	          银行家算法


并行（Parallelism）指多个任务在同一时刻同时执行
并行是说同一时刻做很多操作。多进程是实行并行的有效方法。因为它可以将许多任务分配到计算机的多个核心上。
多进程很适合计算密集型的任务，因为它充分地利用了多个CPU。

并发（Concurrency）指的是，多个任务可以交叉重叠进行

多线程是实现并发的一个手段。
一个进程可以拥有多个线程。当有多个cpu时，多个线程是可以同时执行的，这时就是并行。
如果只有一个cpu，那么多个线程可以交叉重叠执行，这时就是并发了。










